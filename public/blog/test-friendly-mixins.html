<!doctype html>
<html lang="en">
<head>
  <meta name="viewport" content="initial-scale=1">
  <link rel="icon" type="image/png" href="/icons/icon-64.png">
  <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="ATOM Feed">
  <title>Qubyte Codes - Test friendly mixins</title>
  <script src="/index.js" async></script>
  <link href="/main-abb9abe2657ad3dbccae92611ac2b33e.css" rel="stylesheet">
  <link rel="manifest" href="/manifest.json">
  <meta name="theme-color" content="#f1e7cd">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:site" content="@qubyte">
  <meta name="twitter:title" content="Test friendly mixins">
  <meta name="twitter:description" content="This post is all about abusing instanceof customisation further to make mixins work with it.">
</head>
<body>
  <header class="top-header">
    <h1><a href="/">Qubyte Codes</a></h1>
    <nav>
      <ul>
        <li><a href="/">archive</a></li>
        <li><a href="/about">about</a></li>
      </ul>
    </nav>
  </header>
  <div class="content">
    <article>
      <header>
        <h2>Test friendly mixins</h2>
        <time datetime="2017-07-20T13:30Z">Thu Jul 20 2017</time>
      </header>
      <p>I&#39;ve recently been attempting to code a clone of the classic game asteroids
using canvas in the browser. Since this is me, I&#39;ve been distracted by all sorts
of programming detours.</p>
<p>This post is roughly the process I went through for one such detour.</p>
<p>I began planning the game by sketching out the objects it would contain. This
lead to a relatively (for the subject matter) deep class hierarchy including an
abstract entity as a base class, a ship class, an asteroid class, a bullet
class, and so on. It quickly became obvious that it was getting convoluted, with
some repetition to avoid artificial seeming relationships between these classes.</p>
<p>To avoid this sort of convolution, I could eschew classes in favour of plain
objects and mixins, where mixins embody chunks of useful behaviour which are
copied onto host objects. For example, most objects in the game can move, so I&#39;d
write a mixin function to copy a move method onto host objects.</p>
<p>I&#39;m not a purist though. There&#39;s still value to a base class to encode all
essential properties of all objects in the game. Extending the base class for
other objects in the game makes sense for those behaviours and properties unique
to the child class. For example, the ship can be controlled by the user, so such
control would be defined as part of the <code>Ship</code> child class. Other behaviours
will not be unique to child classes, so these can go into mixins.</p>
<p>There are various approaches to mixins in the wild, but I decided to roll my
own. I wrote a function which builds and returns another function. The returned
function applies a mixin. It looked like this:</p>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createMixin</span>(<span class="hljs-params">descriptors</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mix</span>(<span class="hljs-params">obj</span>) </span>{
    <span class="hljs-built_in">Object</span>.defineProperties(obj, descriptors);
  };
}
</code></pre>
<p>The argument <code>descriptors</code> is an object with <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties">property descriptors</a>. I use
these rather than simple object fields since it allows me to create mixins which
are extremely configurable.</p>
<p>Using this I can program the bulk of the behaviour of objects in the game. For
example, since all objects can be assumed to have position and velocity, one
such mixin could add a <code>move</code> method (which I suggested earlier in this post):</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> movable = createMixin({
  <span class="hljs-attr">move</span>: {
    value(dt) {
      <span class="hljs-keyword">this</span>.position.x += <span class="hljs-keyword">this</span>.velocity.x * dt;
      <span class="hljs-keyword">this</span>.position.y += <span class="hljs-keyword">this</span>.velocity.y * dt;
    },
    <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// These three properties</span>
    enumerable: <span class="hljs-literal">false</span>,  <span class="hljs-comment">// are like how class</span>
    writable: <span class="hljs-literal">true</span>      <span class="hljs-comment">// methods are set.</span>
  }
});
</code></pre>
<p>Consider the ship at the centre of the game. We could code it like this:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> ship = {
  <span class="hljs-attr">position</span>: { <span class="hljs-attr">x</span>: <span class="hljs-number">50</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">50</span> },
  <span class="hljs-attr">velocity</span>: { <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">2</span> }
};

movable(ship); <span class="hljs-comment">// Apply the mixin.</span>

ship.move(<span class="hljs-number">2</span>); <span class="hljs-comment">// Now at x: 51, y: 52</span>
</code></pre>
<p>I want the ship to be a class extending a base class though:</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// Base class for all game objects.</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Entity</span> </span>{
  <span class="hljs-keyword">constructor</span>({ position, velocity }) {
    <span class="hljs-keyword">this</span>.position = { <span class="hljs-attr">x</span>: position.x, <span class="hljs-attr">y</span>: position.y };
    <span class="hljs-keyword">this</span>.velocity = { <span class="hljs-attr">x</span>: velocity.x, <span class="hljs-attr">y</span>: velocity.y };
  }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ship</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Entity</span> </span>{
  <span class="hljs-comment">// Ship specific behaviour in here.</span>
}

<span class="hljs-comment">// Give all Ship instances access to move.</span>
movable(Ship.prototype);

<span class="hljs-keyword">const</span> ship = <span class="hljs-keyword">new</span> Ship({
  <span class="hljs-attr">position</span>: { <span class="hljs-attr">x</span>: <span class="hljs-number">50</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">50</span>},
  <span class="hljs-attr">velocity</span>: { <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">2</span> }
});

movable(ship); <span class="hljs-comment">// Apply the mixin.</span>

ship.move(<span class="hljs-number">2</span>); <span class="hljs-comment">// Now at x: 51, y: 52</span>
</code></pre>
<p>All sorts of objects and classes may be composed with mixins.</p>
<p>I&#39;m a professional JavaScript programmer, which means that each time I write
something there&#39;s a little voice in my head asking me how hard it&#39;ll be to write
tests for it. Applying the mixin to a simple object makes writing tests for the
mixin in isolation is possible. In mocha:</p>
<pre><code class="lang-javascript">describe(<span class="hljs-string">'movable'</span>, () =&gt; {
  it(<span class="hljs-string">'appends a single method "move"'</span>, () =&gt; {
    <span class="hljs-keyword">const</span> entity = {
      <span class="hljs-attr">position</span>: { <span class="hljs-attr">x</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">0</span> },
      <span class="hljs-attr">velocity</span>: { <span class="hljs-attr">x</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">0</span> }
    };

    movable(entity);

    assert.equal(<span class="hljs-keyword">typeof</span> entity.move, <span class="hljs-string">'function'</span>);
  });

  it(<span class="hljs-string">'updates the position given a dt'</span>, () =&gt; {
    <span class="hljs-keyword">const</span> entity = {
      <span class="hljs-attr">position</span>: { <span class="hljs-attr">x</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">6</span> },
      <span class="hljs-attr">velocity</span>: { <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">2</span> }
    };

    movable(entity);

    entity.move(<span class="hljs-number">3</span>);

    assert.deepEqual(entity.position, { <span class="hljs-attr">x</span>: <span class="hljs-number">8</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">12</span> });
  });
});
</code></pre>
<p>I&#39;d be more exhaustive in real world tests, but I hope you get the gist.</p>
<p>What about objects which have mixins applied to them though? How can we test
them? Na√Øvely you could write the above tests for every class that uses the
mixin. That&#39;s repetitive though. It would be nicer to have some mechanism to ask
a mixin if an object has had the mixin applied to it. Then test for a class can
use a single test for each mixin to check that the mixin has been applied, and
all the repetition can be avoided.</p>
<p>Revisiting the mixin creating function, the first go at such a mechanism looks
like:</p>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createMixin</span>(<span class="hljs-params">descriptors</span>) </span>{
  <span class="hljs-comment">// References to objects the mixin has been</span>
  <span class="hljs-comment">// applied to.</span>
  <span class="hljs-keyword">const</span> mixed = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakSet</span>();

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mix</span>(<span class="hljs-params">obj</span>) </span>{
    <span class="hljs-built_in">Object</span>.defineProperties(obj, descriptors);
    mixed.add(obj);
  };

  mix.isMixed = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">obj</span>) </span>{
    <span class="hljs-keyword">return</span> mixed.has(obj);
  };

  <span class="hljs-keyword">return</span> mix;
}
</code></pre>
<p>I&#39;ve used a <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/WeakSet"><code>WeakSet</code></a> here. A <code>WeakSet</code> contains <em>weak</em> references to
objects. These are references which the garbage collector ignores. When no
strong references to an object in a <code>WeakSet</code> remain, the garbage collector can
clear the object. If I used a regular <code>Set</code> or an array here, the references
contained would be strong, and references could never be cleaned up
automatically by the garbage collector, resulting in a memory leak. This would
be a problem in particular for asteroids, as each time one is destroyed the
object itself would be held in the <code>Set</code> or array be a strong reference, leading
it to grow as more and more asteroids are spawned.</p>
<p>Now we can ask the mixin if an object has had the mixin applied to it:</p>
<pre><code class="lang-javascript">movable.isMixed(entity); <span class="hljs-comment">// false</span>

movable(entity);

movable.isMixed(entity); <span class="hljs-comment">// true</span>
</code></pre>
<p>What about classes though? This won&#39;t work because the mixin is applied to the
prototype and no reference to an instance will be stored by the mixin. We can
fix this by climbing up the prototype chain and checking each prototype object:</p>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createMixin</span>(<span class="hljs-params">descriptors</span>) </span>{
  <span class="hljs-comment">// References to objects the mixin has been</span>
  <span class="hljs-comment">// applied to.</span>
  <span class="hljs-keyword">const</span> mixed = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakSet</span>();

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mix</span>(<span class="hljs-params">obj</span>) </span>{
    <span class="hljs-built_in">Object</span>.defineProperties(obj, descriptors);
    mixed.add(obj);
  };

  mix.isMixed = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">obj</span>) </span>{
    <span class="hljs-comment">// Walk up the prototype chain and check</span>
    <span class="hljs-comment">// if each step has had the mixin applied</span>
    <span class="hljs-comment">// to it.</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> o = obj; o; o = <span class="hljs-built_in">Object</span>.getPrototypeOf(o)) {
      <span class="hljs-keyword">if</span> (mixed.has(o)) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  };

  <span class="hljs-keyword">return</span> mix;
}
</code></pre>
<p>This works perfectly well now, and any child classes can inherit the method as
expected and the <code>isMixed</code> check will still work. It is now possible to avoid
duplication of tests. For example, part of a test suite for the ship class might
look like:</p>
<pre><code class="lang-javascript">it(<span class="hljs-string">'is movable'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> ship = <span class="hljs-keyword">new</span> Ship({
    <span class="hljs-attr">position</span>: { <span class="hljs-attr">x</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">0</span> },
    <span class="hljs-attr">velocity</span>: { <span class="hljs-attr">x</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">0</span> }
  });

  assert.ok(movable.isMixed(ship));
});
</code></pre>
<p>One final adjustment can be made. It&#39;s a shame that we can use <code>instanceof</code> for
objects constructed by a class, but not objects which have had the mixin applied
to them. This can be achieved by using <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/hasInstance"><code>Symbol.hasInstance</code></a>. A first
attempt:</p>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createMixin</span>(<span class="hljs-params">descriptors</span>) </span>{
  <span class="hljs-keyword">const</span> mixed = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakSet</span>();

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mix</span>(<span class="hljs-params">obj</span>) </span>{
    <span class="hljs-built_in">Object</span>.defineProperties(obj, descriptors);
    mixed.add(obj);
  };

  mix[<span class="hljs-built_in">Symbol</span>.hasInstance] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">obj</span>) </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> o = obj; o; o = <span class="hljs-built_in">Object</span>.getPrototypeOf(o)) {
      <span class="hljs-keyword">if</span> (mixed.has(o)) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      }
    }
  };

  <span class="hljs-keyword">return</span> mix;
}
</code></pre>
<p>Unfortunately this doesn&#39;t work because <code>Function.prototype[Symbol.hasInstance]</code>
is not writable. When appending a property to something, the field you&#39;re
appending it as is checked for writability, and that check propagates up the
prototype chain. Since <code>mix</code> is a function, it has a non-writable
<code>Symbol.hasInstance</code> field in its prototype chain, and we need to work around
that.</p>
<p>We can once again use <code>Object.defineProperty</code> to do it:</p>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createMixin</span>(<span class="hljs-params">descriptors</span>) </span>{
  <span class="hljs-keyword">const</span> mixed = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakSet</span>();

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mix</span>(<span class="hljs-params">obj</span>) </span>{
    <span class="hljs-built_in">Object</span>.defineProperties(obj, descriptors);
    mixed.add(obj);
  };

  <span class="hljs-built_in">Object</span>.defineProperty(mix, <span class="hljs-built_in">Symbol</span>.hasInstance, {
    value(obj) {
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> o = obj; o; o = <span class="hljs-built_in">Object</span>.getPrototypeOf(o)) {
        <span class="hljs-keyword">if</span> (mixed.has(o)) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }
      }
    },
    <span class="hljs-attr">configurable</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>
  });

  <span class="hljs-keyword">return</span> mix;
}
</code></pre>
<p>Finally we can do this:</p>
<pre><code class="lang-javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ship</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Entity</span> </span>{ <span class="hljs-comment">/* ... */</span> }

movable(Ship.prototype);

<span class="hljs-keyword">const</span> ship = <span class="hljs-keyword">new</span> Ship({ <span class="hljs-comment">/* ... */</span> });

ship <span class="hljs-keyword">instanceof</span> Entity;  <span class="hljs-comment">// true</span>
ship <span class="hljs-keyword">instanceof</span> Ship;    <span class="hljs-comment">// true</span>
ship <span class="hljs-keyword">instanceof</span> movable; <span class="hljs-comment">// true</span>
</code></pre>
<p>So the test suite for a ship can include tests like this:</p>
<pre><code class="lang-javascript">it(<span class="hljs-string">'is movable'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> ship = <span class="hljs-keyword">new</span> Ship({
    <span class="hljs-attr">position</span>: { <span class="hljs-attr">x</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">0</span> },
    <span class="hljs-attr">velocity</span>: { <span class="hljs-attr">x</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">0</span> }
  });

  assert.ok(ship <span class="hljs-keyword">instanceof</span> movable);
});
</code></pre>
<p>So there you have it! All the test friendliness of classes with the
composability of mixins.</p>
<p>I wrapped this code up in a module called <a target="_blank" rel="noopener" href="https://www.npmjs.com/package/mixomatic">mixomatic</a>, which I intend to use
heavily in my gaming codebases.</p>

    </article>
    <footer>
      <p>Feel like sharing? <a target="_blank" rel="noopener" href="https://twitter.com/intent/tweet?via=qubyte&amp;text=Qubyte%20Codes%20-%20Test%20friendly%20mixins&amp;url=https%3A%2F%2Fqubyte.codes%2Fblog%2Ftest-friendly-mixins&amp;hashtags=JavaScript,games">Tweet this post!</a></p>
      <p>Comments or corrections? <a target="_blank" rel="noopener" href="https://twitter.com/intent/tweet?screen_name=qubyte">Send me a tweet!</a></p>
      <p>Don't like birdsite? <a target="_blank" rel="noopener" href="https://mastodon.social/@qubyte">Toot to me!</a><p>
    </footer>
  </div>
</body>
</html>
