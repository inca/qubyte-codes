<!doctype html>
<html lang="en">
<head>
  <meta name="viewport" content="initial-scale=1">
  <link rel="icon" type="image/png" href="/icons/icon-64.png">
  <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="ATOM Feed">
  <title>Qubyte Codes - My first custom element</title>
  <script src="/index.js" async></script>
  <link href="/main-0d9985ebbfcfd22aeeefc7c031ae0739.css" rel="stylesheet">
  <link rel="manifest" href="/manifest.json">
  <meta name="theme-color" content="#f1e7cd">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:site" content="@qubyte">
  <meta name="twitter:title" content="My first custom element">
  <meta name="twitter:description" content="This post is an exporation into custom elements.">
</head>
<body>
  <header class="top-header">
    <h1><a href="/">Qubyte Codes</a></h1>
    <nav>
      <ul>
        <li><a href="/">archive</a></li>
        <li><a href="/about">about</a></li>
      </ul>
    </nav>
  </header>
  <div class="content">
    <article class="h-entry">
      <header>
        <h2><a href="https://qubyte.codes/blog/my-first-custom-element" class="u-url p-name">My first custom element</a></h2>
        <time datetime="2017-11-16T01:45Z" class="dt-published">Thu Nov 16 2017</time>
        <span class="tags"><a href="/tags/JavaScript">#JavaScript</a> </span>
      </header>
      <div class="e-content">
        <p>After some years of browser vendors working out what web components should look
like, they&#39;re almost ready for the prime time. The part which I find most
intriguing (custom elements) has finally stabilised. With custom elements, you
can make new HTML elements which have custom behaviour which you define using
JavaScript. In this post I&#39;ll demonstrate a custom element for fuzzy counting.</p>
<p>Custom elements are created in two parts. Firstly we need to extend an element
with a JavaScript class.</p>
<pre><code class="lang-javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FuzzyCount</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HTMLElement</span> </span>{

}
</code></pre>
<p>So far this describes no custom behaviour. All this is is the extended class,
with identical behaviour to an <code>HTMLElement</code>. We can customize the constructor
to add the behaviour we want. In order to give the element data to use, it must
be passed in as an attribute. We&#39;ll use an attribute called <code>count</code>.</p>
<pre><code class="lang-javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FuzzyCount</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HTMLElement</span> </span>{
  <span class="hljs-keyword">constructor</span>() {
    <span class="hljs-comment">// The parent constructor must be called</span>
    <span class="hljs-comment">// before using `this`.</span>
    <span class="hljs-keyword">super</span>();

    <span class="hljs-comment">// rawCount is a string.</span>
    <span class="hljs-keyword">const</span> rawCount = <span class="hljs-keyword">this</span>.getAttribute(<span class="hljs-string">'count'</span>);
    <span class="hljs-keyword">const</span> count = <span class="hljs-built_in">parseInt</span>(rawCount, <span class="hljs-number">10</span>);

    <span class="hljs-comment">// Set text content based on the count.</span>
    <span class="hljs-keyword">if</span> (count === <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">this</span>.textContent = <span class="hljs-string">'none'</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (count === <span class="hljs-number">1</span>) {
      <span class="hljs-keyword">this</span>.textContent = <span class="hljs-string">'one'</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (count === <span class="hljs-number">2</span>) {
      <span class="hljs-keyword">this</span>.textContent = <span class="hljs-string">'a couple'</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (count &lt; <span class="hljs-number">5</span>) {
      <span class="hljs-keyword">this</span>.textContent = <span class="hljs-string">'a few'</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (count &lt; <span class="hljs-number">10</span>) {
      <span class="hljs-keyword">this</span>.textContent = <span class="hljs-string">'several'</span>;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">this</span>.textContent = <span class="hljs-string">'lots'</span>;
    }
  }
}
</code></pre>
<p>The element reads and parses the <code>count</code> attribute, giving itself a text content
accordingly.</p>
<p>To make the element available to a page, it must be registered. One interesting
restriction placed upon custom elements is that they must contain a hyphen so
that they can be distinguished from built-in elements. We&#39;re going to register
our element as <code>fuzzy-count</code>, but in the real world you should prefix it with
a namespace. For example, if we&#39;re working at a place called Funky Corp, we
could name the element <code>funkycorp-fuzzy-count</code>.</p>
<pre><code class="lang-javascript">customElements.define(<span class="hljs-string">'fuzzy-count'</span>, FuzzyCount);
</code></pre>
<p>Now we can use this to make elements on the page!</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">fuzzy-count</span> <span class="hljs-attr">count</span>=<span class="hljs-string">"3"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">fuzzy-count</span>&gt;</span>
</code></pre>
<p>Any matching custom elements which exist before the element is defined will be
upgraded. This means a page can be sent by the server with custom elements
included, and everything will be rendered properly once the custom element is
registered.</p>
<p>But what if we want to create elements in JS? We can try:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> fuzzyCount = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'fuzzy-count'</span>);
</code></pre>
<p>but an error will be thrown. It turns out that newly constructed elements cannot
contain other stuff (the text content). Even if no error was thrown, we&#39;d
have an element with no <code>count</code> attribute, and so we&#39;ve missed our chance since
all the logic is in the contructor. It turns out that the constructor is the
wrong place for this stuff.</p>
<p>Thankfully we can make a few changes to defer the setting of text content.</p>
<pre><code class="lang-javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FuzzyCount</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HTMLElement</span> </span>{
  <span class="hljs-comment">// Called when the element is inserted into</span>
  <span class="hljs-comment">// the document or upgraded.</span>
  connectedCallback() {
    <span class="hljs-keyword">this</span>.setTextContent();
  }

  setTextContent() {
    <span class="hljs-keyword">const</span> rawCount = <span class="hljs-keyword">this</span>.getAttribute(<span class="hljs-string">'count'</span>);

    <span class="hljs-keyword">if</span> (!rawCount) {
      <span class="hljs-keyword">this</span>.textContent = <span class="hljs-string">''</span>;
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">const</span> count = <span class="hljs-built_in">parseInt</span>(rawCount, <span class="hljs-number">10</span>);

    <span class="hljs-keyword">if</span> (count === <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">this</span>.textContent = <span class="hljs-string">'none'</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (count === <span class="hljs-number">1</span>) {
      <span class="hljs-keyword">this</span>.textContent = <span class="hljs-string">'one'</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (count === <span class="hljs-number">2</span>) {
      <span class="hljs-keyword">this</span>.textContent = <span class="hljs-string">'a couple'</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (count &lt; <span class="hljs-number">5</span>) {
      <span class="hljs-keyword">this</span>.textContent = <span class="hljs-string">'a few'</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (count &lt; <span class="hljs-number">10</span>) {
      <span class="hljs-keyword">this</span>.textContent = <span class="hljs-string">'several'</span>;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">this</span>.textContent = <span class="hljs-string">'lots'</span>;
    }
  }
}
</code></pre>
<p>The logic which sets the <code>textContent</code> has moved to its own method
<code>setTextContent</code>, and <code>connectedCallback</code> calls it when the element is
&quot;connected&quot; to avoid the error when constructing the element in JS. Connected is
called when the element is inserted into the document, or the element is
upgraded by custom element registration.</p>
<p>This is enough to get the behaviour we want, so long as the count attribute
of a new <code>fuzzy-count</code> element is set <em>before</em> it is appended to the document.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> fuzzy = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'fuzzy-count'</span>);
fuzzy.setAttribute(<span class="hljs-string">'count'</span>, <span class="hljs-number">10</span>);
<span class="hljs-built_in">document</span>.body.appendChild(fuzzy);
</code></pre>
<p>We can take one more step to make the element react to changes to the count
attribute...</p>
<pre><code class="lang-javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FuzzyCount</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HTMLElement</span> </span>{
  <span class="hljs-comment">// Called for each watched attribute when</span>
  <span class="hljs-comment">// the element is added to the document or</span>
  <span class="hljs-comment">// upgraded. Also fired for a watched</span>
  <span class="hljs-comment">// attribute when it is added, updated, or</span>
  <span class="hljs-comment">// removed.</span>
  attributeChangedCallback() {
    <span class="hljs-keyword">this</span>.setTextContent();
  }

  <span class="hljs-comment">// A static getter because we can't add a</span>
  <span class="hljs-comment">// static value within a class declaration</span>
  <span class="hljs-comment">// directly (yet).</span>
  <span class="hljs-keyword">static</span> get observedAttributes() {
    <span class="hljs-keyword">return</span> [<span class="hljs-string">'count'</span>];
  }

  setTextContent() {
    <span class="hljs-comment">// Same as before.</span>
  }
}
</code></pre>
<p><code>connectedCallback</code> has been replaced with <code>attributeChangedCallback</code>, and a
static getter defines the list of attributes to watch. For each watched
attribute, when an element is inserted, upgraded, or the attribute is added,
updated, or removed, this <code>attributeChangedCallback</code> is called. These changes
allow us to update elements before appending as before, and also <em>after</em>
appending.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> fuzzy = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'fuzzy-count'</span>);
<span class="hljs-built_in">document</span>.body.appendChild(fuzzy);
fuzzy.setAttribute(<span class="hljs-string">'count'</span>, <span class="hljs-number">10</span>);
</code></pre>
<p>Overall I&#39;m impressed. I&#39;ve only covered some of the API available here. It <em>is</em>
a little fiddly, but upon consideration it all seems to make sense so far. It
strikes me that a good way to use it would be for small components, or as a low
level primitive for a front end framework.</p>
<p>Finally, a note on compatibility. At the time of writing Chrome and Safari
support custom elements with no additional effort. Other browsers must be
<a target="_blank" rel="noopener" href="https://github.com/webcomponents/custom-elements">polyfilled</a> for support.</p>

      </div>
    </article>
    <footer>
      <p>Feel like sharing? <a target="_blank" rel="noopener" href="https://twitter.com/intent/tweet?via=qubyte&amp;text=Qubyte%20Codes%20-%20My%20first%20custom%20element&amp;url=https://qubyte.codes/blog/my-first-custom-element&amp;hashtags=JavaScript">Tweet this post!</a> or <a target="_blank" rel="noopener" href="web+mastodon://share?text=Qubyte%20Codes%20-%20My%20first%20custom%20element%20via%20%40qubyte%40mastodon.social%20%23JavaScript%20https%3A%2F%2Fqubyte.codes%2Fblog%2Fmy-first-custom-element">toot it!</a></p>
      <p>Comments or corrections? <a target="_blank" rel="noopener" href="https://twitter.com/intent/tweet?screen_name=qubyte">Send me a tweet!</a> or <a target="_blank" rel="noopener" href="web+mastodon://share?text=%40qubyte%40mastodon.social">toot to me!</a></p>
    </footer>
  </div>
</body>
</html>
